"""Newsletter generator for weekly risk reports"""

from typing import Dict, Optional
from datetime import datetime, timedelta
from pathlib import Path
import jinja2

from btc_engine.database.client import db_client
from btc_engine.utils.config_loader import settings
from btc_engine.utils.constants import OUTPUTS_DIR
from btc_engine.utils.logging_config import logger


TEMPLATE = """# BTC Options + Onchain Weekly Risk Report

**Week of {{ week_start.strftime('%Y-%m-%d') }}**  
**Generated: {{ now.strftime('%Y-%m-%d %H:%M UTC') }}**

---

## Executive Summary

{{ summary_bullets }}

---

## Current Market Regime

**Regime Classification**: {{ regime_name }} ({{ regime_prob }}% probability)

**Latent State Estimates**:
- Risk Appetite: {{ state_risk_appetite }}
- Leverage Stress: {{ state_leverage_stress }}
- Dealer Stabilization: {{ state_dealer_stabilization }}
- Tail Demand: {{ state_tail_demand }}

**Interpretation**: {{ regime_interpretation }}

---

## Options Market Structure

**Surface Factors**:
- IV Level (ATM): {{ iv_level }}%
- Skew: {{ skew }} ({{ skew_direction }})
- Curvature: {{ curvature }}
- Term Structure: {{ term_structure }}

**Hedging Pressure**:
- Stabilization Index: {{ stabilization_index }}
- Acceleration Index: {{ acceleration_index }}
- Max Gamma Strike: ${{ max_gamma_strike }}

**Interpretation**: {{ options_interpretation }}

---

## Onchain Fundamentals

**Mechanical Indices**:
- Supply Elasticity: {{ supply_elasticity }} ({{ elasticity_regime }})
- Forced Flow Index: {{ forced_flow }} ({{ flow_regime }})
- Liquidity Impulse: {{ liquidity_impulse }} ({{ liquidity_regime }})

**Key Observations**:
{{ onchain_observations }}

---

## Divergence Analysis

**Current Classification**: {{ divergence_class }}

**Divergence Score**: {{ divergence_score }}

**Top Contributing Signals**:
{% for signal in top_signals %}
{{ loop.index }}. {{ signal.name }}: {{ signal.value }}
{% endfor %}

**Implication**: {{ divergence_implication }}

---

## Distributional Forecasts

### 24-Hour Outlook

| Quantile | Return | Price Target |
|----------|--------|--------------|
| 5%       | {{ forecast_24h.q05 }}% | ${{ forecast_24h.price_q05 }} |
| 25%      | {{ forecast_24h.q25 }}% | ${{ forecast_24h.price_q25 }} |
| 50%      | {{ forecast_24h.q50 }}% | ${{ forecast_24h.price_q50 }} |
| 75%      | {{ forecast_24h.q75 }}% | ${{ forecast_24h.price_q75 }} |
| 95%      | {{ forecast_24h.q95 }}% | ${{ forecast_24h.price_q95 }} |

**Tail Risk**: {{ forecast_24h.tail_risk }}

### 7-Day Outlook

| Quantile | Return | Price Target |
|----------|--------|--------------|
| 5%       | {{ forecast_7d.q05 }}% | ${{ forecast_7d.price_q05 }} |
| 50%      | {{ forecast_7d.q50 }}% | ${{ forecast_7d.price_q50 }} |
| 95%      | {{ forecast_7d.q95 }}% | ${{ forecast_7d.price_q95 }} |

---

## Risk Memo

### Key Risks This Week

{{ risk_bullets }}

### Recommended Positioning

{{ positioning_recommendation }}

### Watch List

{{ watch_list }}

---

## Charts

![Options Surface Factors](images/surface_factors.png)

![Hedging Pressure Map](images/pressure_map.png)

![Divergence Score](images/divergence.png)

![Forecast Fan Chart](images/forecast_fan.png)

---

*This report is generated by the BTC Options + Onchain Inference Engine. For methodology details, see the documentation.*
"""


class NewsletterGenerator:
    """Generate weekly newsletter reports"""
    
    def __init__(self):
        """Initialize newsletter generator"""
        self.template = jinja2.Template(TEMPLATE)
        self.output_dir = OUTPUTS_DIR / "newsletters"
        self.output_dir.mkdir(exist_ok=True, parents=True)
    
    def fetch_latest_data(self) -> Dict:
        """Fetch latest data for newsletter
        
        Returns:
            Dictionary with all data needed for template
        """
        data = {}
        
        # Get latest timestamps
        latest_surface = db_client.get_latest_timestamp("features_options_surface")
        latest_state = db_client.get_latest_timestamp("model_states")
        
        if not latest_surface or not latest_state:
            raise ValueError("Missing required data for newsletter generation")
        
        # Current time
        data['now'] = datetime.now()
        data['week_start'] = datetime.now() - timedelta(days=7)
        
        # Regime info
        state_query = "SELECT * FROM model_states WHERE timestamp = ? ORDER BY timestamp DESC LIMIT 1"
        df_state = db_client.query_to_dataframe(state_query, (latest_state,))
        
        if len(df_state) > 0:
            state = df_state.iloc[0]
            
            # Find dominant regime
            regime_probs = [
                state.get('regime_1_prob', 0),
                state.get('regime_2_prob', 0),
                state.get('regime_3_prob', 0)
            ]
            regime_names = ['Risk On', 'Compression', 'Distress']
            max_idx = np.argmax(regime_probs)
            
            data['regime_name'] = regime_names[max_idx]
            data['regime_prob'] = f"{regime_probs[max_idx]*100:.1f}"
            
            data['state_risk_appetite'] = f"{state.get('state_risk_appetite', 0):.3f}"
            data['state_leverage_stress'] = f"{state.get('state_leverage_stress', 0):.3f}"
            data['state_dealer_stabilization'] = f"{state.get('state_dealer_stabilization', 0):.3f}"
            data['state_tail_demand'] = f"{state.get('state_tail_demand', 0):.3f}"
        
        # Options data
        surface_query = "SELECT * FROM features_options_surface WHERE timestamp = ?"
        df_surface = db_client.query_to_dataframe(surface_query, (latest_surface,))
        
        if len(df_surface) > 0:
            surface = df_surface.iloc[0]
            data['iv_level'] = f"{surface.get('level', 0)*100:.2f}"
            data['skew'] = f"{surface.get('skew', 0):.4f}"
            data['curvature'] = f"{surface.get('curvature', 0):.4f}"
            data['term_structure'] = f"{surface.get('term_structure', 0):.4f}"
            
            skew_val = surface.get('skew', 0)
            data['skew_direction'] = "negative (put demand)" if skew_val < 0 else "positive (call demand)"
        
        # Hedging pressure
        pressure_query = "SELECT * FROM features_hedging_pressure WHERE timestamp <= ? ORDER BY timestamp DESC LIMIT 1"
        df_pressure = db_client.query_to_dataframe(pressure_query, (latest_surface,))
        
        if len(df_pressure) > 0:
            pressure = df_pressure.iloc[0]
            data['stabilization_index'] = f"{pressure.get('stabilization_index', 0):.4f}"
            data['acceleration_index'] = f"{pressure.get('acceleration_index', 0):.4f}"
            data['max_gamma_strike'] = f"{pressure.get('max_gamma_strike', 0):.0f}"
        
        # Onchain
        onchain_query = "SELECT * FROM features_onchain_indices ORDER BY timestamp DESC LIMIT 1"
        df_onchain = db_client.query_to_dataframe(onchain_query)
        
        if len(df_onchain) > 0:
            onchain = df_onchain.iloc[0]
            data['supply_elasticity'] = f"{onchain.get('supply_elasticity', 0):.2f}"
            data['forced_flow'] = f"{onchain.get('forced_flow_index', 0):.2f}"
            data['liquidity_impulse'] = f"{onchain.get('liquidity_impulse', 0):.2f}"
            
            # Add regime labels
            data['elasticity_regime'] = "inelastic" if onchain.get('supply_elasticity', 0) < -0.5 else "elastic"
            data['flow_regime'] = "elevated" if onchain.get('forced_flow_index', 0) > 1 else "normal"
            data['liquidity_regime'] = "positive" if onchain.get('liquidity_impulse', 0) > 0 else "negative"
        
        # Divergence
        div_query = "SELECT * FROM features_divergence ORDER BY timestamp DESC LIMIT 1"
        df_div = db_client.query_to_dataframe(div_query)
        
        if len(df_div) > 0:
            div = df_div.iloc[0]
            data['divergence_class'] = div.get('classification', 'Unknown')
            data['divergence_score'] = f"{div.get('divergence_score', 0):.2f}"
            
            top_signals = []
            for i in range(1, 6):
                signal_name = div.get(f'top_signal_{i}')
                signal_value = div.get(f'top_signal_{i}_value')
                if signal_name:
                    top_signals.append({'name': signal_name, 'value': f"{signal_value:.4f}"})
            
            data['top_signals'] = top_signals
        
        # Default interpretations
        data['regime_interpretation'] = "See methodology for regime definitions."
        data['options_interpretation'] = "Current options structure reflects market positioning."
        data['onchain_observations'] = "- Supply dynamics remain stable\n- Flow patterns within normal ranges"
        data['divergence_implication'] = "Signals are generally aligned."
        data['summary_bullets'] = "- Market regime identified\n- Forecasts generated\n- No major divergences detected"
        data['risk_bullets'] = "- Monitor tail risk metrics\n- Watch for regime transitions"
        data['positioning_recommendation'] = "Maintain balanced exposure with attention to tail hedges."
        data['watch_list'] = "- Divergence score changes\n- Regime probability shifts\n- Supply elasticity trends"
        
        # Placeholder forecasts
        data['forecast_24h'] = {
            'q05': '-2.5', 'price_q05': '46,800',
            'q25': '-0.8', 'price_q25': '47,616',
            'q50': '0.0', 'price_q50': '48,000',
            'q75': '+0.9', 'price_q75': '48,432',
            'q95': '+3.1', 'price_q95': '49,488',
            'tail_risk': 'Moderate downside risk (5% tail at -2.5%)'
        }
        
        data['forecast_7d'] = {
            'q05': '-8.5', 'price_q05': '43,920',
            'q50': '0.5', 'price_q50': '48,240',
            'q95': '+12.3', 'price_q95': '53,904'
        }
        
        return data
    
    def generate(self, week_date: Optional[datetime] = None) -> Path:
        """Generate newsletter for given week
        
        Args:
            week_date: Date in week to generate for (defaults to current week)
            
        Returns:
            Path to generated newsletter
        """
        if week_date is None:
            week_date = datetime.now()
        
        logger.info(f"Generating newsletter for week of {week_date}")
        
        # Fetch data
        try:
            data = self.fetch_latest_data()
        except Exception as e:
            logger.error(f"Failed to fetch newsletter data: {e}")
            raise
        
        # Render template
        content = self.template.render(**data)
        
        # Save to file
        filename = f"weekly_report_{week_date.strftime('%Y_%W')}.md"
        output_path = self.output_dir / filename
        
        with open(output_path, 'w') as f:
            f.write(content)
        
        logger.info(f"Newsletter saved to {output_path}")
        
        return output_path


def generate_weekly_newsletter(week_date: Optional[datetime] = None) -> Path:
    """Generate weekly newsletter
    
    Args:
        week_date: Week date
        
    Returns:
        Path to newsletter file
    """
    generator = NewsletterGenerator()
    return generator.generate(week_date)
